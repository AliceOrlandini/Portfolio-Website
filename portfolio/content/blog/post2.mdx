---
title: Post 2
description: This is a test post ciao
date: 2023-11-01
published: true
---
### Generics

Gli algoritmi possono essere scritti utilizzando **tipi di dato parametrizzati** (parametric data types), che vengono definiti in modo generico e specificati solo a tempo di esecuzione. Questo approccio ha lo scopo di evitare la duplicazione del codice, consentendo di scrivere funzioni o strutture dati che funzionano con diversi tipi di dato, migliorando così il controllo e la manutenibilità del codice.

In **Java**, i tipi di dato parametrizzati sono chiamati **Generics** e permettono di definire classi, metodi o interfacce utilizzando placeholder per i tipi di dato, che verranno assegnati al momento dell'uso.

Un esempio è: 

<CodeBlock
    language="java"
    filename="File1.jsx"
    highlightLines={[9, 13, 14, 18]}
    code={`public class Box<T> {
    private T value;

    public void set(T value) {
        this.value = value;
    }

    public T get() {
        return value;
    }
}`}
  />

In questo esempio, la classe `Box` utilizza un tipo generico `T`, che può essere specificato quando si crea un'istanza della classe. Ciò consente di utilizzare la stessa classe `Box` per contenere diversi tipi di oggetti, senza riscrivere il codice.

Il meccanismo che consente ai **Generics** di funzionare in Java è chiamato **Type Erasure** (cancellazione dei tipi). Durante la compilazione, il tipo generico viene mantenuto solo fino a quando il compilatore ha eseguito tutti i controlli di tipo necessari. Una volta terminati questi controlli, il tipo specifico viene "cancellato" o sostituito con il tipo più generico (come `Object` o un tipo specifico per i limiti), e quindi la **JVM** non ha più informazioni sui tipi generici a tempo di esecuzione.

Una limitazione è che poiché i tipi generici vengono cancellati dopo la compilazione, non è possibile determinare il tipo effettivo di un oggetto generico a tempo di esecuzione. Questo significa che non è possibile, ad esempio, interrogare il tipo di un oggetto generico usando il reflection per scoprire il tipo effettivo che è stato utilizzato (ad esempio usando `lista.getClass()`.

Il campo **Next Header** del base header di IPv6 contiene al suo interno le informazioni riguardo al tipo di dati contenuti nel prossimo header. 
Esso può assumere diversi valori, a seconda del protocollo o del tipo di header che segue l'header IPv6 di base. 
Ecco alcuni dei valori più comuni:
1. **6**: TCP (Transmission Control Protocol)
2. **17**: UDP (User Datagram Protocol)
3. **1**: ICMPv4 (Internet Control Message Protocol for IPv4)
4. **58**: ICMPv6 (Internet Control Message Protocol for IPv6)
5. **43**: Routing Header (per indirizzare il pacchetto attraverso uno specifico percorso)
6. **44**: Fragment Header (per la frammentazione dei pacchetti IPv6)
7. **50**: ESP (Encapsulating Security Payload) - usato per IPsec
8. **51**: AH (Authentication Header) - usato per IPsec
9. **59**: No Next Header (indica che non ci sono altri header successivi)
10. **60**: Destination Options Header (usato per informazioni aggiuntive specifiche del destinatario)

Gli **ACL basati sull'upper layer** invece guardano oltre l'header IPv6 e controllano le informazioni presenti nei protocolli di livello superiore, come TCP o UDP. Ad esempio, potrebbero esaminare le porte TCP/UDP, il numero di sequenza o altri dati del livello di trasporto o applicazione.

![ACL upper layers|center|500](https://www.cisco.com/en/US/technologies/tk648/tk872/images/technologies_white_paper0900aecd8054d37d-14.jpg)

Alcuni prefissi permettono di capire la tipologia di indirizzo:

| Allocation            | Prefisso in binario | Prefisso in esadecimale | Frazione dello spazio di indirizzamento |
| --------------------- | ------------------- | ----------------------- | --------------------------------------- |
| Non assegnato         | 0000 0000           | ::0/8                   | 1/256                                   |
| Riservato             | 0000 001            | ::1/7                   | 1/128                                   |
| Global Unicast (GUA)  | 001                 | 2000::/3                | 1/8                                     |
| Link-Local Unicast    | 1111 1110 10        | FE80::/10               | 1/1024                                  |
| Riservato             | 1111 1110 11        | FEC0::/10* deprecato    | 1/1024                                  |
| Unique Local (ULA)    | 1111 110            | FC00::/7                |                                         |
| Amministratore Locale | 1111 1101           | FD00::/8                |                                         |
| Multicast             | 1111 1111           | FF00::/8                | 1/256                                   |

Un pacchetto ICMPv6 ha la seguente struttura:
1. **Type (8 bit)**: Specifica il tipo di messaggio ICMPv6 (ad esempio, messaggi di errore o di informazione). Alcuni esempi di tipi includono:
	- Tipo 1: Messaggio di destinazione irraggiungibile.
	- Tipo 2: Packet Too Big (utile per l'MTU).
	- Tipo 3: Time Exceeded (usato nell'hop by hop).
	- Tipo 4: Parameter Problem (il formato del pacchetto è errato).
1. **Code (8 bit)**: Specifica ulteriori dettagli sul tipo di messaggio, indicando la sottocategoria dell'errore o dell'informazione.
2. **Checksum (16 bit)**: Controlla l'integrità del pacchetto ICMPv6, verificando eventuali errori nei dati. Questo campo è necessario perché ora il checksum è responsabilità dei layer superiori visto che è stato rimosso da IPv6.
3. **Message-specific data**: Ogni tipo di messaggio può avere dati specifici.